<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JAVASE基础</title>
    <url>/2023/03/09/javaSE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<span id="more"></span>
<p>软件开发流程</p>
<p>需求分析</p>
<p>概要设计</p>
<p>详细设计</p>
<p>编程</p>
<p>测试</p>
<p>实施</p>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><p>定义：标记某段代码所表达的意思，方便查看代码功能</p>
<p>单行注释（&#x2F;&#x2F;）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//将100赋值给变量i</span></span><br></pre></td></tr></table></figure>

<p>多行注释（&#x2F;* *&#x2F;）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文档注释（&#x2F;**  *&#x2F;）:这是Java独有的注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是一个实体类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-标识符"><a href="#1-2-标识符" class="headerlink" title="1.2 标识符"></a>1.2 标识符</h2><p><strong>定义</strong>：可以自己取名（如：类名，属性名，方法名）</p>
<p><strong>规则</strong>：①0-9，a-z，A-Z，下划线组成</p>
<p>​			②数字不能开头</p>
<p>​			③不可以使用关键字和保留字（关键字：Java自己定义的变量名，保留字：goto，const）</p>
<p>​			④长度无限，但是中间不能有空格</p>
<p>​			⑤严格区分大小写</p>
<p><strong>规范（驼峰命名法）</strong>：①类名：多单词组成，首字母大写</p>
<p>​									   ②属性名和方法名：多字母组成，第二个单词首字母大写</p>
<p>​									   ③包名：全小写</p>
<p>​										④常量名：全大写，多单词组成，用下划线连接</p>
<h2 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h2><p><strong>含义：</strong>内存的一个存储区域，拥有自己的名称和类型（先声明再使用）</p>
<p><strong>公式</strong>：数据类型  变量名 &#x3D; 变量值</p>
<p><strong>数据类型</strong>：分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。<strong>基本数据类型</strong>分为数值型，字符型，布尔型；引用数据类型风味					类，接口，数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;      <span class="comment">// 存储1字节</span></span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">// 存储2字节</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;      <span class="comment">// 存储4字节</span></span><br><span class="line"><span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10</span>;     <span class="comment">// 存储8字节</span></span><br><span class="line"><span class="type">float</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10.0f</span>;  <span class="comment">// 存储4字节</span></span><br><span class="line"><span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10.0</span>;   <span class="comment">// 存储8字节</span></span><br><span class="line"><span class="type">char</span> <span class="variable">g</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;     <span class="comment">// 字符型</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 布尔型，只有true和false两个值</span></span><br></pre></td></tr></table></figure>

<p><strong>存储方法：</strong> <strong>基本数据类型</strong>局部变量存储在栈内存，成员变量的值存储在堆内存，栈内存存储指向堆内存的地址；					<strong>引用数据类型</strong>将值存储在在堆内存，栈内存存储指向堆内存的地址</p>
<p><strong>声明位置：</strong>声明在类的内部，方法体外，为<strong>成员变量</strong>；声明在类的内部，方法体内，为<strong>局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="type">int</span> i;  <span class="comment">//成员变量 不需要手动初始化，系统自动初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 局部变量 一定要手动初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换：</strong>byte，short，char会自动转换成int类型，再进行计算；</p>
<p>​					强制转换：将大的数据类型转换成小的数据类型（有可能会失去精确度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a;  <span class="comment">//b的结果为10</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h2><p><strong>算术运算符：</strong>整除（&#x2F;）保留整数；取余（%）保留小数部分，当被除数为负数时，忽略符号</p>
<p><strong>赋值运算符：</strong>先计算&#x3D;右边，再复制于&#x3D;的左边</p>
<p><strong>比较运算符：</strong>&gt;,&lt;,&lt;&#x3D;,&gt;&#x3D;,&#x3D;&#x3D;,!&#x3D;,instanceof  (<strong>注：</strong>小的数据类型与大的数据类型进行计算时，会自动转换成大的根据						类型，再计算结果；instanceof用于判断对象是否为某个类型创建的)</p>
<p><strong>逻辑运算符：</strong>|，||，&amp;，&amp;&amp;，！ （<strong>注：</strong>单与和单或是两边都要比较），^(异或：相同为假，不同为真)</p>
<p><strong>三元运算符：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (a&gt;b)?a:b; <span class="comment">// a&gt;b时，max = a;a&lt;b时，max = b</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-分支"><a href="#1-5-分支" class="headerlink" title="1.5 分支"></a>1.5 分支</h2><p>if else语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>；</span><br><span class="line"><span class="comment">//ifelse语句，当满足if小括号里的条件,程序走if语句，不满足时，走else语句</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">9</span>)&#123;</span><br><span class="line">	System.out.println(a+<span class="string">&quot;大于9&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;    <span class="comment">// 相当于判断a&lt;=9</span></span><br><span class="line">	System.out.println(a+小于<span class="number">9</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>switch语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// switch只能对byte,short,int,String,enum类型判断</span></span><br><span class="line"><span class="keyword">switch</span>(a)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-循环"><a href="#1-6-循环" class="headerlink" title="1.6 循环"></a>1.6 循环</h2><p>for语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印输出0到9</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 打印输出0到9 只要满足while小括号的条件，就一直循环</span></span><br><span class="line"><span class="keyword">while</span>(a&lt;<span class="number">10</span>)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do whlie语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">// 先进行循环，再去判断</span><br><span class="line">do&#123;</span><br><span class="line">	System.out.println(a);</span><br><span class="line">	a--;</span><br><span class="line">&#125;while();</span><br></pre></td></tr></table></figure>

<p>嵌套循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环次数为外层循环乘以内层循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java你好&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-数组"><a href="#1-7-数组" class="headerlink" title="1.7 数组"></a>1.7 数组</h2><blockquote>
<p><strong>定义公式（一维数组）：</strong>数据类型[] 变量名 &#x3D; new 数据类型[数组长度] （动态定义）</p>
<p>数据类型[] 变量名 &#x3D; {……}  （静态定义）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];  <span class="comment">//动态定义</span></span><br><span class="line">    <span class="type">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//静态定义</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">        System.out.println(i);     <span class="comment">// 循环遍历数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Arrays  数组工具类</span></span><br><span class="line">    Arrays.toString(a);  <span class="comment">//输出数组</span></span><br><span class="line">    Arrays.sort(a);   <span class="comment">// 升序排列数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定义公式（二维数组）</strong>：数据类型[][] [] [] 变量名 &#x3D; new 数据类型 [] [];(动态定义)</p>
<p>数据类型[] [] 变量名 &#x3D; { {……}，{……} };(静态定义)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">a</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 三行四列的二维数组</span></span><br><span class="line"><span class="type">int</span>[][] b = &#123;&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 循环遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;a.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;a[i].length;j++)&#123;</span><br><span class="line">        System.out.println(a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h4><p>​	方法就是封装体现</p>
<p>​	限制对属性的不合理操作，将属性私有化，提供getXXX()和setXXX()方法进行逻辑控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>子类继承父类，就继承了父类中的属性和方法（私有的除外）</p>
<p>多个类中存在相同的属性和方法时，把多个类中的相同的内容放在一个类中，然后让其他类来继承。</p>
<p>一个父类可以有多个子类，一个子类只能有一个父类，子类可以继续扩展子类</p>
<p>子类构造器在调用父类构造器</p>
<p>继承的出现让类于类之间产生了关系，提供了多态的前提</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在Java中多态有两种体现：①方法的重载和方法的重写是属性多态的一种表现形式   ② 对象的多态性</p>
<p>抽象类和接口就是多态最好的体现</p>
<p>在Java存在编译是类型和运行时类型，当编译时类型与运行时类型不一致就发生了多态（编译时类型与运行时类型有继承关系）</p>
<p>写代码时为运行时类型，调用的都是父类的方法，运行时产生的时子类对象，调用的都是子类重写和独有的方法</p>
<p>使用多态时都是在参数传递时使用</p>
<p>调用子类重写的方法或继承的方法也称为动态绑定机制（虚拟方法调用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="引用数据类型转换"><a href="#引用数据类型转换" class="headerlink" title="引用数据类型转换"></a>引用数据类型转换</h5><p>方法的参数如果是父类类型，传入的是子类对象，此时就发生了类型转换</p>
<p>引用数据类型也有自动和强制</p>
<p>自动：子类自动变成父类</p>
<p>强制：父类强制变成子类，需要类型判断（instanceof）才能强制</p>
<h5 id="抽象类（大类别）"><a href="#抽象类（大类别）" class="headerlink" title="抽象类（大类别）"></a>抽象类（大类别）</h5><p>有抽象方法的类必须是抽象类</p>
<p>抽象类可以有普通方法和抽象方法</p>
<p>抽象类有构造器</p>
<p>抽象类可以继承</p>
<p>抽象类不能实例化</p>
<p>抽象类不能用final修饰</p>
<p>抽象类设计目的就是为了子类继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类如果没有重写全部的抽象方法，那么子类依然为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">bird</span>() <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接口（小区别）"><a href="#接口（小区别）" class="headerlink" title="接口（小区别）"></a>接口（小区别）</h5><p>接口属于引用数据类型</p>
<p>接口只有静态常量和抽象方法（没有构造器）</p>
<p>接口用interface定义</p>
<p>设计接口是为了子类实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AImpl</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>集合（Collection）</title>
    <url>/2023/03/14/%E9%9B%86%E5%90%88%EF%BC%88Collection%EF%BC%89/</url>
    <content><![CDATA[<h1 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection）</h1><h2 id="一-、List集合（单元素集合）"><a href="#一-、List集合（单元素集合）" class="headerlink" title="一 、List集合（单元素集合）"></a>一 、List集合（单元素集合）</h2><p><strong>特点：</strong>有序可重复</p>
<h3 id="1-1-ArrayList"><a href="#1-1-ArrayList" class="headerlink" title="1.1 ArrayList"></a>1.1 ArrayList</h3><p><strong>特点</strong>：list的实现类，基于数组实现的集合，有序可重复，元素内存较为集中，查询速度快，增改删效率慢，线程不安全</p>
<p>实际应用（见代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="comment">//插入指定位置</span></span><br><span class="line">        list.add(<span class="number">1</span>,<span class="string">&quot;sss&quot;</span>);</span><br><span class="line">        <span class="comment">//获取特定的位置</span></span><br><span class="line">        list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//根据下标删除元素</span></span><br><span class="line">        list.remove(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//根据元素内容删除元素</span></span><br><span class="line">        list.remove(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断集合是否为空</span></span><br><span class="line">       	list.isEmpty();</span><br><span class="line">        <span class="comment">//清空集合</span></span><br><span class="line">        list.clear();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出list集合,重写了toString()方法，隐式调用</span></span><br><span class="line">        System.out.println(list); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结果为true 集合重写了equals方法，但是数组不行，因为Java没有为数组这种数据类型设计专门的类，所以没法重写equals(),但是提供了Arrays.equals()</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        System.out.println(list.equals(list1));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//迭代器 从上到下 遍历输出集合</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">listIterator</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">		<span class="keyword">while</span>(listIterator.hasNext()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(listIterator.next().equals(<span class="string">&quot;aa&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//				listIterator.add(&quot;cc&quot;);</span></span><br><span class="line">				listIterator.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从下往上List集合独有 游标上移</span></span><br><span class="line">		<span class="keyword">while</span>(listIterator.hasPrevious()) &#123;</span><br><span class="line">			System.out.println(listIterator.previous());</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        list.subList(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-LinkedList集合"><a href="#1-2-LinkedList集合" class="headerlink" title="1.2 LinkedList集合"></a>1.2 LinkedList集合</h3><p>特点：基于双向链表实现的集合，有序可重复，元素内存地址分散，查询效率慢，增改查效率快</p>
<p>实际应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLinkedList</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//在首位和最后一位添加元素</span></span><br><span class="line">		list.addFirst(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		list.addLast(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//查看首位和最后一位的元素</span></span><br><span class="line">		System.out.println(list.peekFirst());</span><br><span class="line">		System.out.println(list.peekLast());</span><br><span class="line">		<span class="comment">//在首位添加元素</span></span><br><span class="line">		list.push(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		<span class="comment">// 去掉首部元素</span></span><br><span class="line">		list.pop();</span><br><span class="line">		</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、Set集合（单元素集合）"><a href="#二、Set集合（单元素集合）" class="headerlink" title="二、Set集合（单元素集合）"></a>二、Set集合（单元素集合）</h2><p><strong>特点：</strong>无序不重复，没有扩展Collection，Set集合是根据hashcode值来决定存储位置，但是hashcode有一个缺点，不同元素的hashcode有可能相同</p>
<h3 id="2-1-HashSet集合"><a href="#2-1-HashSet集合" class="headerlink" title="2.1 HashSet集合"></a>2.1 HashSet集合</h3><p><strong>特点：</strong> 无序不重复，Set集合的默认实现类</p>
<p>实际应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashSet</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		</span><br><span class="line">		set.add(<span class="string">&quot;a&quot;</span>);<span class="comment">//隐式调用hashcode方法  也在调用equals</span></span><br><span class="line">		set.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		set.add(<span class="number">1</span>);</span><br><span class="line">		set.add(<span class="number">2</span>);</span><br><span class="line">		set.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储自定义的对象时，需要在自定义类中重写equals()和hashcode()方法</span></span><br><span class="line">        不然调用的都是默认，满足不了实际需求</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>));</span><br><span class="line">		set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(set);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h3 id="2-2-LinkedHashSet集合"><a href="#2-2-LinkedHashSet集合" class="headerlink" title="2.2 LinkedHashSet集合"></a>2.2 LinkedHashSet集合</h3><p><strong>特点：</strong>有序不重复，实际还无序不重复，只不过还是基于双向链表实现</p>
<p>实际应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLinkedHashSet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        list2.add(<span class="number">2</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-TreeSet集合"><a href="#2-3-TreeSet集合" class="headerlink" title="2.3 TreeSet集合"></a>2.3 TreeSet集合</h3><p><strong>特点：</strong> <strong>可排序的集合</strong>，只能存放一种数据类型的元素，默认时升序</p>
<p>实际应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自然排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.name.equals(student.name))&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.score == <span class="built_in">this</span>.score)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTreeSet</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//定制排序</span></span><br><span class="line">		<span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">				</span><br><span class="line">				System.out.println(<span class="string">&quot;定制排序....&quot;</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">					<span class="type">Student</span> <span class="variable">p1</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">					<span class="type">Student</span> <span class="variable">p2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">					<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">					<span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> p1.getScore() - p2.getScore();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> a;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="type">TreeSet</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">		</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="number">11</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;owen&quot;</span>,<span class="number">12</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;owen&quot;</span>,<span class="number">13</span>));</span><br><span class="line">		</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>① 自然排序在对可控类使用；定制排序对不可控类使用（可控就是可以修改源码）</p>
<p>​		② TreeSet在存储自定义对象时，自定义类需要实现Comparable接口；或者定义一个Comparator对象，不然会出现ClassCastException异常（类型不可转换异常）</p>
<h2 id="三、Map（双元素集合）"><a href="#三、Map（双元素集合）" class="headerlink" title="三、Map（双元素集合）"></a>三、Map（双元素集合）</h2><p><strong>特点：</strong>存储键值对（key - value）</p>
<p>实现类：① HashMap: key值存储无序不重复，value不做要求；HashSet的实现底层就是HashMap；HashMap是由数组+双向链表+红黑数（<strong>注</strong>：当数值长度大于64时或者链表长度大于8时，将会转变成红黑树）</p>
<p>​				② LinkedHashMap：key有序不重复，LinkedHashSet的底层实现为LinkedHashMap</p>
<p>​				③ TreeMap：key存储可排序，TreeSet的底层实现为TreeMap</p>
<p>​				④ HashTable：古老的实现类</p>
<p>​				⑤ Properties：继承于HashTable，用于操作属性文件</p>
<p><strong>实际应用（HashMap为主）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMap</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);<span class="comment">//没有则添加，有则修改</span></span><br><span class="line">		map.put(<span class="number">100</span>, <span class="literal">true</span>);</span><br><span class="line">		map.put(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">		map.put(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>);</span><br><span class="line">		map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>), <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">// map是可以允许存储空key和空value</span></span><br><span class="line">		map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;刘德华&quot;</span>,<span class="number">60</span>), <span class="literal">null</span>);</span><br><span class="line">		</span><br><span class="line">		map.remove(<span class="string">&quot;a&quot;</span>);<span class="comment">//根据key删除键值对   隐式调用equals</span></span><br><span class="line">		Map&lt;String,String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		map1.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		map.putAll(map1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(map.containsKey(<span class="string">&quot;a&quot;</span>));<span class="comment">//equals</span></span><br><span class="line">		System.out.println(map.containsValue(<span class="literal">true</span>));<span class="comment">//equals</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(map.get(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>)));<span class="comment">//通过key获取value值   equals</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(map.size());</span><br><span class="line">		</span><br><span class="line">		System.out.println(map);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();<span class="comment">//获取map中所有的value放入到Collection集合中</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();<span class="comment">//获取map中所有的key放入到set集合中</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">			<span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;--&gt;&quot;</span>+value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();<span class="comment">////获取map中entry放入到Set集合中</span></span><br><span class="line">		<span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator2.hasNext()) &#123;</span><br><span class="line">			Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Entry) iterator2.next();</span><br><span class="line">			System.out.println(entry.getKey()+<span class="string">&quot;==&gt;&quot;</span>+entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>① 当HashMap存储自定义类的对象时，自定义类需要重写equals()和hashcode()</p>
<p>​		② HashMap存储的是key-value，提供keySet()方法，返回值为Set集合；提供values()方法，返回值为Collection集合；提供entrySet()方法，返回值为Set集合，HashMap将key-value封装成了一个个的entry对象。</p>
<p>​		③ 使用Iterator迭代器对map中的元素进行遍历</p>
<h3 id="3-1-Properties（操作属性文件）"><a href="#3-1-Properties（操作属性文件）" class="headerlink" title="3.1 Properties（操作属性文件）"></a><strong>3.1 Properties（操作属性文件）</strong></h3><p><strong>实际应用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//操作属性文件--通过key读取value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProperties</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>));<span class="comment">//加载磁盘文件到程序中</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		System.out.println(username+password);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2023/03/14/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><strong>含义（粗浅的理解）：</strong>在理想的情况下，写出的程序应该会按照我的思想去运行，但是呢，人无完人，总是有考虑不完全的时候，这时候程序就有可能出现一些异常和错误。</p>
<h2 id="一、-异常的类型"><a href="#一、-异常的类型" class="headerlink" title="一、 异常的类型"></a>一、 异常的类型</h2><h3 id="1-1-运行时异常"><a href="#1-1-运行时异常" class="headerlink" title="1.1 运行时异常"></a>1.1 运行时异常</h3><p><strong>含义：</strong>在编译阶段无法感知代码是否出现问题，只有在程序运行时才会出错，这样的异常被称为<strong>运行时异常</strong>。</p>
<blockquote>
<p>异常也由类定义的，所以的运行时异常都继承于RuntimeException</p>
<p>RuntimeException继承于Exception</p>
<p>Exception继承于ThrowException</p>
</blockquote>
<h3 id="1-2-编译时异常"><a href="#1-2-编译时异常" class="headerlink" title="1.2 编译时异常"></a>1.2 编译时异常</h3><p><strong>含义：</strong>编译时异常是需要明确指出可能会出现的异常，在编译阶段就需要进行处理（捕捉异常），如果不进行处理。将无法通过编译。</p>
<blockquote>
<p>默认继承自Exception类的异常都是编译时异常</p>
</blockquote>
<p><strong>注：</strong>文件未找到异常：FileNotFoundException就是一个非常典型的编译时异常（饱受折磨）</p>
<h3 id="1-3-错误（Error）"><a href="#1-3-错误（Error）" class="headerlink" title="1.3 错误（Error）"></a>1.3 错误（Error）</h3><p><strong>含义：</strong>错误比异常更严重，异常不一定会导致致命的问题，但是错误是致命问题，一版出现错误可能jvm无法继续正常运行，例如StackOverError就是内存溢出错误（递归没有结束符号）</p>
<blockquote>
<p>Error继承于Throwable</p>
<p>Error是所有错误的父类</p>
</blockquote>
<h3 id="1-4-自定义异常"><a href="#1-4-自定义异常" class="headerlink" title="1.4 自定义异常"></a>1.4 自定义异常</h3><p>自定义编译时异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123; <span class="comment">// message表示错误的原因</span></span><br><span class="line">        <span class="built_in">super</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义运行时异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123; <span class="comment">// message表示错误的原因</span></span><br><span class="line">        <span class="built_in">super</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、-抛出异常"><a href="#二、-抛出异常" class="headerlink" title="二、 抛出异常"></a>二、 抛出异常</h2><blockquote>
<p>当调用方法时，如果因为错误的参数导致程序无法正常运行时，我们可以手动抛出一个异常来阻止程序继续运行下去（利用throw关键字）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;被除数不能为0&quot;</span>); <span class="comment">// 使用throw抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在方法中抛出一个非运行时异常，那么就一定要告知方法的调用者，我们会抛出这个异常（利用关键字throws）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是必须告知的异常&quot;</span>); <span class="comment">// 使用throw抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、-异常的处理"><a href="#三、-异常的处理" class="headerlink" title="三、 异常的处理"></a>三、 异常的处理</h2><blockquote>
<p>之前已经了解到了如何将异常抛出（渣男行为），那么我们要如何去将抛出的异常处理呢（坚决不做渣男，咱是有责任心的），这就要用到try-catch-finally语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是必须告知的异常&quot;</span>); <span class="comment">// 使用throw抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            test(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">            System.out.println(e.getMessage); <span class="comment">// 获取错误的信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一定能运行的&quot;</span>); <span class="comment">// finally是一定可以运行的，常用于关闭一些连接（后期会遇见）</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序继续进行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获。</p>
<p><strong>注：</strong>如果某个方法明确指出会抛出那些异常，除非是运行时异常，否则我们一定要用try-catch-finally语句进行捕捉，不然就无法通过编译。</p>
<p>渣男行为（不推荐）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是必须告知的异常&quot;</span>); <span class="comment">// 使用throw抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        test(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>此时发生异常时，就会直接交给JVM处理，默认让整个程序终止并打印栈追踪信息</p>
<blockquote>
<p>使用一个try-catch语句时，catch语句可以有多个，异常要从小到大的排序</p>
</blockquote>
<h2 id="常见的异常（SE阶段可能遇见的）："><a href="#常见的异常（SE阶段可能遇见的）：" class="headerlink" title="常见的异常（SE阶段可能遇见的）："></a>常见的异常（SE阶段可能遇见的）：</h2><p>算术异常类：ArithmeticExecption</p>
<p>空指针异常类：NullPointerException</p>
<p>类型强制转换异常：ClassCastException</p>
<p>数组负下标异常：NegativeArrayException</p>
<p>数组下标越界异常：ArrayIndexOutOfBoundsException</p>
<p>文件未找到异常：FileNotFoundException</p>
<p>字符串转换为数字异常：NumberFormatException</p>
<p>操作数据库异常：SQLException</p>
<p>输入输出异常：IOException</p>
<p>方法未找到异常：NoSuchMethodException</p>
]]></content>
  </entry>
  <entry>
    <title>new接口？</title>
    <url>/2023/03/09/new%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>new接口？？？接口不是没有构造器，不能new吗？？？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">A</span>,B&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//利用匿名内部类的方式去&quot;new&quot;接口</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;lala&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的class文件<br><img src="/../pic/1.png"></p>
<p>编译器会自动生成一个Test$1.class去实现接口</p>
<p>通过反编译：</p>
<p><img src="/../pic/2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>搭建个人博客（血与泪的教训）</title>
    <url>/2023/03/16/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88hexo+git+github+nodejs%EF%BC%89/</url>
    <content><![CDATA[<h1 id="搭建个人博客（hexo-git-github-nodejs）"><a href="#搭建个人博客（hexo-git-github-nodejs）" class="headerlink" title="搭建个人博客（hexo+git+github+nodejs）"></a>搭建个人博客（hexo+git+github+nodejs）</h1><h2 id="1、安装git"><a href="#1、安装git" class="headerlink" title="1、安装git"></a>1、安装git</h2><p>进入git官网进行下载（官网：<a href="https://git-scm.com/">Git (git-scm.com)</a>）：</p>
<p><img src="/../pic/%E4%B8%8B%E8%BD%BDgit.png" alt="下载git"></p>
<p><img src="/../pic/git2.PNG" alt="git2"></p>
<p><img src="/../pic/git3.PNG" alt="git3"></p>
<p>安装git：</p>
<p><img src="/../pic/git%E5%AE%89%E8%A3%85.PNG" alt="git安装"></p>
<p><img src="/../pic/git%E5%AE%89%E8%A3%852.PNG" alt="git安装2"></p>
<p>后续默认安装即可</p>
<p><img src="/../pic/git%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F1.png" alt="git安装成功1"></p>
<p>点击Git Bash Here，输入git指令：</p>
<p><img src="/../pic/1678784868781.png" alt="1678784868781"></p>
<p>到了这一步，git就安装就好了，随着学习的深入，git的作用会越来越大，也是一个非常好用工具（必备）</p>
<blockquote>
<p>git命令框内的复制：Ctrl+Ins；粘贴：Shift+Ins</p>
</blockquote>
<h2 id="2、安装nodejs"><a href="#2、安装nodejs" class="headerlink" title="2、安装nodejs"></a>2、安装nodejs</h2><p>百度搜索nodejs，下载即可（傻瓜式安装，建议不要放在c盘）</p>
<p>官网：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p>
<p><img src="/../pic/nodejs%E4%B8%8B%E8%BD%BD.PNG" alt="nodejs下载"></p>
<p><img src="/../pic/%E5%AE%89%E8%A3%851.PNG" alt="安装1"></p>
<p><img src="/../pic/%E5%AE%89%E8%A3%852.PNG" alt="安装2"></p>
<p><img src="/../pic/%E5%AE%89%E8%A3%853.PNG" alt="安装3"></p>
<p>后续直接默认安装就行了</p>
<p>使用cmd来确认安装成功：<img src="/../pic/%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.PNG" alt="安装成功"></p>
<p>出现版本号就说明安装成功了</p>
<h2 id="3、注册github，并设置ssh公钥（git直接登录github，下载文件）"><a href="#3、注册github，并设置ssh公钥（git直接登录github，下载文件）" class="headerlink" title="3、注册github，并设置ssh公钥（git直接登录github，下载文件）"></a>3、注册github，并设置ssh公钥（git直接登录github，下载文件）</h2><p>建议使用加速器，国内访问GitHub太不稳定（百度搜索Steam++）</p>
<p>第一步没有GitHub账号的，先注册GitHub，（给GitHub打波广告，最大的开源社区，在里面你可以找到任何资源）</p>
<p>利用git设置ssh公钥（打开git命令窗口）</p>
<blockquote>
<p>输入：ssh</p>
</blockquote>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh1.PNG" alt="设置ssh1"></p>
<blockquote>
<p>输入：ssh-keygen -t rsa（注意空格）</p>
<p>再按回车键4次，会生成两个文件：id_rsa和id_rsa.pub</p>
<p>Windows系统默认路径：C:&#x2F;Users&#x2F;（你的用户名）&#x2F;.ssh</p>
<p>Mac系统默认路径：~&#x2F;.ssh</p>
<p>复制id_rsa.pub文件内的内容（用记事本打开）</p>
</blockquote>
<p>登录Github</p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh.PNG" alt="设置ssh"></p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh3.PNG" alt="设置ssh3"></p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh4.PNG" alt="设置ssh4"></p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh5.PNG" alt="设置ssh5"></p>
<p>添加成功后</p>
<blockquote>
<p>输入：ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a></p>
</blockquote>
<p>第一次使用会出现这种，输入yes即可</p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh6.PNG" alt="设置ssh6"></p>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AEssh7.PNG" alt="设置ssh7"></p>
<h2 id="4、在GitHub上建立托管的仓库"><a href="#4、在GitHub上建立托管的仓库" class="headerlink" title="4、在GitHub上建立托管的仓库"></a>4、在GitHub上建立托管的仓库</h2><p><img src="/../pic/%E5%BB%BA%E7%AB%8B%E4%BB%93%E5%BA%931.PNG" alt="建立仓库1"></p>
<p><img src="/../pic/%E5%BB%BA%E7%AB%8B%E4%BB%93%E5%BA%932.PNG" alt="建立仓库2"></p>
<p><img src="/../pic/%E5%BB%BA%E7%AB%8B%E4%BB%93%E5%BA%933.PNG" alt="建立仓库3"></p>
<p><img src="/../pic/%E5%BB%BA%E7%AB%8B%E4%BB%93%E5%BA%934.PNG" alt="建立仓库4"></p>
<p>出现这个，就说明仓库建立好了</p>
<p><img src="/../pic/%E5%BB%BA%E7%AB%8B%E4%BB%93%E5%BA%935.PNG" alt="建立仓库5"></p>
<h2 id="5、安装hexo，搭建个人博客"><a href="#5、安装hexo，搭建个人博客" class="headerlink" title="5、安装hexo，搭建个人博客"></a>5、安装hexo，搭建个人博客</h2><p>在<strong>除系统盘外</strong>的盘内新建一个文件，例如Test（文件名随意）；点开文件夹，右键打开菜单，点击Git Bash Here，进入git命令框</p>
<blockquote>
<p>输入：npm install -g hexo-cli   （安装Hexo）</p>
</blockquote>
<p><img src="/../pic/%E5%AE%89%E8%A3%85hexo1.PNG" alt="安装hexo1"></p>
<p>初始化hexo：</p>
<blockquote>
<p>输入：hexo init</p>
</blockquote>
<p><img src="/../pic/%E5%AE%89%E8%A3%85hexo2.PNG" alt="安装hexo2"></p>
<p>静态部署：</p>
<blockquote>
<p>输入：hexo g</p>
</blockquote>
<p><img src="/../pic/%E5%AE%89%E8%A3%85hexo3.PNG" alt="安装hexo3"></p>
<p>本地查看：</p>
<blockquote>
<p>输入：hexo s</p>
</blockquote>
<p><img src="/../pic/%E5%AE%89%E8%A3%85hexo4.PNG" alt="安装hexo4"></p>
<p>打开浏览器，将<a href="http://localhost:4000/%E8%BE%93%E5%85%A5%EF%BC%9A">http://localhost:4000/输入：</a></p>
<p><img src="/../pic/%E6%98%BE%E7%A4%BAhexo.PNG" alt="显示hexo"></p>
<p>查看完毕，回到命令框，按住Ctrl+C，结束服务器运行</p>
<h2 id="6、将Hexo部署到GitHub上"><a href="#6、将Hexo部署到GitHub上" class="headerlink" title="6、将Hexo部署到GitHub上"></a>6、将Hexo部署到GitHub上</h2><p>打开你建立在GitHub上的仓库</p>
<p><img src="/../pic/%E9%83%A8%E7%BD%B22.PNG" alt="部署2"></p>
<p>打开文件夹，找到_config.yml</p>
<p><img src="/../pic/%E9%83%A8%E7%BD%B21.PNG" alt="部署1"></p>
<p>将原本的内容改为下面（repository为你的仓库地址）</p>
<blockquote>
<p>deploy:<br>  type: git<br>  repository:   #你的仓库地址<br>  branch: master</p>
</blockquote>
<p>接着就是将项目上传至GitHub仓库内</p>
<blockquote>
<p>依次输入：</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo d</p>
</blockquote>
<p><img src="/../pic/%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F.PNG" alt="上传成功"></p>
<p>上传成功后，还没结束（之前我到了这一步，以为结束了，但是用自己设置的域名死活显示不出来，经过一个多星期的折磨，我终于解决的这个问题）</p>
<p>打开你的GitHub仓库</p>
<p><img src="/../pic/%E9%83%A8%E7%BD%B23.PNG" alt="部署3"></p>
<p><img src="/../pic/%E9%83%A8%E7%BD%B24.PNG" alt="部署4"></p>
<p>设置完这个，就可以通过<a href="https://yqlt5.github.io(https//%E5%8A%A0%E4%B8%8A%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%E5%95%A6">https://yqlt5.github.io（https://加上你的仓库名查看效果啦</a></p>
<h2 id="7、上传笔记（使用Typora）"><a href="#7、上传笔记（使用Typora）" class="headerlink" title="7、上传笔记（使用Typora）"></a>7、上传笔记（使用Typora）</h2><p>搭建好了个人博客，是不是就要上传自己的笔记或者感悟，不然不就是个空架子嘛，房子都建好了，不添点家具岂不可惜。在这介绍两种上传形式。</p>
<p><strong>第一种，已经写完的笔记怎么上传呢</strong></p>
<p>打开项目根目录，找到source目录，点开它，找到_posts目录，将已经写好的笔记复制到该目录中</p>
<p>用记事本打开写好的笔记本，在最上面加上：</p>
<p><img src="/../pic/%E7%A4%BA%E4%BE%8B1.PNG" alt="示例1"></p>
<p>_posts目录中有hello-world.md文件，用记事本打开，直接复制这段就可以了，title：后面写上笔记的题目</p>
<p>然后在_posts目录下打开git命令框</p>
<blockquote>
<p>依次输入：</p>
<p>hexo g</p>
<p>hexo d</p>
</blockquote>
<p>这样，在个人博客就可以看到上传的笔记：</p>
<p><img src="/../pic/%E7%A4%BA%E4%BE%8B2.PNG" alt="示例2"></p>
<p>第二种 如何利用hexo生成笔记</p>
<p>在_posts目录下打开git命令行</p>
<blockquote>
<p>输入： hexo new “(笔记的名字)”</p>
</blockquote>
<p><img src="/../pic/%E7%94%9F%E6%88%90%E7%AC%94%E8%AE%B0.PNG" alt="生成笔记"></p>
<p>它会生成一个后缀名为md的文件和一个同名的文件名</p>
<p><img src="/../pic/%E7%A4%BA%E4%BE%8B3.PNG" alt="示例3"></p>
<p>接着你就可以在.md文件中写笔记了，不用复制title了，以为已经生成了</p>
<p>写完，提交就好了，同第一种的上传方式一样</p>
<h2 id="8、解决笔记中图片上传的问题（还得靠自己一步步试错）"><a href="#8、解决笔记中图片上传的问题（还得靠自己一步步试错）" class="headerlink" title="8、解决笔记中图片上传的问题（还得靠自己一步步试错）"></a>8、解决笔记中图片上传的问题（还得靠自己一步步试错）</h2><p>这又是一个非常折磨的问题，一开始在网上找了各种各样的解决方式，但是都没解决，我一度想自己搭建一个图床，当我想动手的时候，我刚好在b站看到了鱼皮（b站up主：程序员鱼皮）被人刷了将近2万块，我放弃了这个想法，钱包禁不住造。虽然这对我是不太可能的事情，但是避免意外，放弃了。</p>
<p>功夫不负有心人，我终于找到了解决方法。</p>
<p>一般我们插入图片都是绝对路径，可是一旦上传，访问不到本地的资源，所以我们要把图片也上传上去，利用相对路径去访问，这是解决思路。</p>
<p>在source下新建一个文件，我建了一个名为pic的文件，专门放插入的图片：</p>
<p><img src="/../pic/%E7%A4%BA%E4%BE%8B4.PNG" alt="示例4"></p>
<p>按住Ctrl+逗号打开偏好设置</p>
<p><img src="/../pic/%E7%A4%BA%E4%BE%8B6.PNG"></p>
<p>这样就可以了插入图片时，优先使用相对路径，再上传时就可以看到图片了</p>
<h2 id="9、优化个人博客"><a href="#9、优化个人博客" class="headerlink" title="9、优化个人博客"></a>9、优化个人博客</h2><blockquote>
<p>Hexo界面过于大众化，我很不喜欢，肯定要优化它，作为自己的个人博客，肯定是需要包含自己独特的记号，不然我整这玩意干嘛（鉴于个人能力问题，优化的不是很多，后续慢慢更新）</p>
</blockquote>
<p>第一步先找一个主题（我现在使用的是next主题，不怎么花里胡哨）</p>
<p>打开项目目录，右键Git Bash Here，下载next主题</p>
<blockquote>
<p>输入：git clone <a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a> themes&#x2F;next</p>
</blockquote>
<p><img src="/../pic/%E4%BC%98%E5%8C%961.PNG" alt="优化1"></p>
<p>第二步在个人博客上添加自己独特的元素</p>
<p>打开项目根目录，找到_config.yml</p>
<p>找到以下内容：</p>
<blockquote>
<p>#Site</p>
<p>title: Hexo         #标题<br>subtitle: ‘’<br>description: ‘’        #简介或者自己喜欢的句子<br>keywords:<br>author: John Doe    #作者名<br>language: en         #语言<br>timezone: ‘’				#时间</p>
</blockquote>
<p>language设置要查看主题支持哪种语言，如果主题是不支持的话，会出现乱码的情况</p>
<p>查看主题支持的语言（点开项目根目录，找到themes，点开themes目录，找到next目录，点开它，找到languages，点开它）</p>
<p><img src="/../pic/%E8%AF%AD%E8%A8%80.PNG" alt="语言"></p>
<p>我的设置（仅供参考）：</p>
<p><img src="/../pic/%E6%A8%A1%E6%9D%BF1.PNG" alt="模板1"></p>
<p>设置完后，在项目根目录下，打开git命令框：</p>
<blockquote>
<p>依次输入：</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo d</p>
</blockquote>
<p>这样，部分优化就结束啦（优化慢慢更新）</p>
<h3 id="（1）添加头像"><a href="#（1）添加头像" class="headerlink" title="（1）添加头像"></a>（1）添加头像</h3><blockquote>
<p>打开根目录下的themes，打开next目录，打开source下的images目录，将你要设置的图片放入其中，并重命名为avatar.图片后缀，将avatar.gif删除</p>
<p>接着找到next目录下的_config.yml文件，找到avatar</p>
</blockquote>
<p><img src="/../pic/%E8%AE%BE%E7%BD%AE%E5%A4%B4%E5%83%8F.PNG"></p>
<p>url：修改最后的图片后缀即可</p>
<p>rounded：头像显示在圈圈内，不喜欢可以填false</p>
<p>rotated：头像会根据鼠标的方向转圈（个人表示不喜）</p>
<p>这样头像就设置好了</p>
<h3 id="（2）添加搜索功能"><a href="#（2）添加搜索功能" class="headerlink" title="（2）添加搜索功能"></a>（2）添加搜索功能</h3><p>下载搜索插件</p>
<blockquote>
<p>npm  install  hexo-generator-searchdb</p>
</blockquote>
<p>在主题的_config.yml文件中</p>
<p><img src="/../pic/%E6%90%9C%E7%B4%A2.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/03/27/%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%EF%BC%89/</url>
    <content><![CDATA[<h1 id="项目（个人用户中心）"><a href="#项目（个人用户中心）" class="headerlink" title="项目（个人用户中心）"></a>项目（个人用户中心）</h1><p>前端</p>
<p>安装ant design pro（先安装nodejs）</p>
<p>初始化：npm i @ant-design&#x2F;pro-cli -g  （初始化脚手架）</p>
<p>​				pro create myapp</p>
<p>安装一个自动生成前端界面代码的可视化编程工具</p>
<p>npm install –save-dev @umijs&#x2F;preset-ui</p>
]]></content>
  </entry>
  <entry>
    <title>八股文</title>
    <url>/2023/03/18/Java%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<h1 id="Java八股文"><a href="#Java八股文" class="headerlink" title="Java八股文"></a>Java八股文</h1><h2 id="参考网站："><a href="#参考网站：" class="headerlink" title="参考网站："></a>参考网站：</h2><p>基础知识：<a href="https://github.com/wolverinn/Waking-Up">https://github.com/wolverinn/Waking-Up</a></p>
<h2 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h2><h3 id="（1）final关键字的作用？"><a href="#（1）final关键字的作用？" class="headerlink" title="（1）final关键字的作用？"></a>（1）final关键字的作用？</h3><blockquote>
<p>被final修饰的类不可被继承（断子绝孙）</p>
<p>被final修饰的方法不能被重写，JVM会尝试将其内联，提高运行效率（内联函数，详情见：<a href="https://blog.csdn.net/ke_weiquan/article/details/51946174">(38条消息) JVM 方法内联_柯柯为为的博客-CSDN博客</a>）</p>
<p>被final修饰的变量不能被改变</p>
<p>修饰引用，表示引用不可变，指向的内容可变（例如：单例模式）</p>
<p>修饰常量，在编译阶段会存入常量池中</p>
</blockquote>
<h3 id="（2）抽象类（abstract）和接口（interface）有什么区别？"><a href="#（2）抽象类（abstract）和接口（interface）有什么区别？" class="headerlink" title="（2）抽象类（abstract）和接口（interface）有什么区别？"></a>（2）抽象类（abstract）和接口（interface）有什么区别？</h3><blockquote>
<p><strong>抽象类：</strong>声明方法的存在而不实现；用于创建一个表明某些基本行为的类，并为该类声明方法，但是不实现方法；抽象类不能对象实例化，需要一个子类去继承实现抽象类，子类如果没有实现父类的全部抽象方法，仍未抽象类；不能有抽象构造方法和抽象静态方法</p>
<p><strong>意义：</strong>为其他子类提供一个公共的类型；封装子类中重复定义的内容；定义抽象方法，子类虽然不同的实现，但是定义时是一致的</p>
</blockquote>
<blockquote>
<p><strong>接口：</strong>只有抽象方法和静态变量；接口可以实现多继承；</p>
</blockquote>
<h3 id="（3）Java集合类：list，set，queue，map，stack的特点与使用"><a href="#（3）Java集合类：list，set，queue，map，stack的特点与使用" class="headerlink" title="（3）Java集合类：list，set，queue，map，stack的特点与使用"></a>（3）Java集合类：list，set，queue，map，stack的特点与使用</h3><blockquote>
<p><strong>List类（单元素集合）：</strong>有序可重复，基于数组实现，可以在任意位置添加删除元素，用Iterator实现单向遍历，用ListIterator实现双向遍历</p>
</blockquote>
<blockquote>
<p><strong>Set类（单元素集合）：</strong>无序不重复，基于双向链表实现，集合中只能包含一个null元素，用Iterator实现单向遍历，没有同步方法（线程不安全）</p>
</blockquote>
<blockquote>
<p><strong>Queue类（队列）：</strong>遵循先进先出原则，使用offer（）来添加元素，使用poll（）来移除元素，不允许插入null元素</p>
</blockquote>
<blockquote>
<p><strong>Map类（双元素集合）：</strong>存储键值对（key-value），key唯一不可重复，value可重复，可将key和value单独抽取出来，KeySet（）方法将key抽取为一个Set集合，Values（）方法见value抽取为一个Collection集合，entrySet（）方法将键值对抽取为一个Set集合，利用Iterator遍历输出</p>
</blockquote>
<blockquote>
<p><strong>Stack类（栈）：</strong>遵循后进后出的原则，继承自Vector，允许将向量视为堆栈，提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法</p>
</blockquote>
<p>使用：</p>
<p>① 如果涉及堆栈，队列等操作，建议使用List</p>
<p>② 对于快速插入和删除元素，建议使用LinkedList</p>
<p>③ 需要快速随机访问元素，建议使用ArrayList</p>
<h3 id="（4）ArrayList，Vector，LinkedList的存储性能和特性"><a href="#（4）ArrayList，Vector，LinkedList的存储性能和特性" class="headerlink" title="（4）ArrayList，Vector，LinkedList的存储性能和特性"></a>（4）ArrayList，Vector，LinkedList的存储性能和特性</h3><blockquote>
<p>ArrayList和Vector都是基于数组实现的，他们都允许直接按照序号索引元素，但是插入元素涉及数组元素移动等内存操作，所以索引数据快而插入元素慢，而且Vector使用了synchronized方法（线程安全），所以效率比ArrayList差</p>
<p>LinkedList是基于双向链表实现，按序号索引数据需要进行向前或后边遍历，但是插入数据是只需要记录本项的前后项即可，所以插入速度较快</p>
</blockquote>
<h3 id="（5）内存泄露和内存溢出"><a href="#（5）内存泄露和内存溢出" class="headerlink" title="（5）内存泄露和内存溢出"></a>（5）内存泄露和内存溢出</h3><blockquote>
<p><strong>内存泄露：</strong>应用程序在申请内存后，无法释放已经申请的内存空间，一次内存泄露可以忽略，但是任其发展最终会导致内存溢出。例如IO流读取数据后，要及时关闭流以及对数据库连接的释放（try-with-resource语法可以自动关闭）</p>
</blockquote>
<blockquote>
<p><strong>内存溢出：</strong>应用程序在申请内存时，没有足够的内存空间供其使用。例如在项目中对于大批量数据的导入，采用分批量提交的方式。</p>
</blockquote>
<h3 id="（6）反射中，Class-forName-和ClassLoader-loadClass-的区别"><a href="#（6）反射中，Class-forName-和ClassLoader-loadClass-的区别" class="headerlink" title="（6）反射中，Class.forName()和ClassLoader.loadClass()的区别"></a>（6）反射中，Class.forName()和ClassLoader.loadClass()的区别</h3><blockquote>
<p><strong>Class.forName()方法：</strong>实际调用的是Class.forName(className,true,classloader)；第二个boolean参数表示类是否需要初始化，一旦初始化，就会触发目标对象的static代码块执行，static变量也会被再次初始化</p>
</blockquote>
<blockquote>
<p><strong>ClassLoader.loadClass()方法：</strong>实际调用的方法是ClassLoader.loadClass(className,false)，第二个boolean参数，表示目标对象是否进行链接，false表示不进行链接，不进行包括初始化等一系列操作（静态块和静态对象也不会得到执行）</p>
</blockquote>
<h3 id="（7）Int和Integer的区别"><a href="#（7）Int和Integer的区别" class="headerlink" title="（7）Int和Integer的区别"></a>（7）Int和Integer的区别</h3><blockquote>
<p>Integer是Int的包装类，在拆箱和装箱中，二者互相转换；</p>
<p>Int是基本类型直接存储数值，integer是引用数据类型存储地址值</p>
</blockquote>
<h3 id="（8）String，StringBuilder，StringBuffer区别"><a href="#（8）String，StringBuilder，StringBuffer区别" class="headerlink" title="（8）String，StringBuilder，StringBuffer区别"></a>（8）String，StringBuilder，StringBuffer区别</h3><table>
<thead>
<tr>
<th><strong>String</strong></th>
<th><strong>字符串常量</strong></th>
<th><strong>不可变</strong></th>
<th><strong>使用字符串拼接时是两个不同的2个空间</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>StringBuilder</strong></td>
<td><strong>字符串常量</strong></td>
<td><strong>可变</strong></td>
<td><strong>线程不安全，字符串拼接直接在字符串后追加</strong></td>
</tr>
<tr>
<td><strong>StringBuffer</strong></td>
<td><strong>字符串常量</strong></td>
<td><strong>可变</strong></td>
<td><strong>线程安全，字符串拼接直接在字符串后追加</strong></td>
</tr>
</tbody></table>
<p>① StringBuilder执行效率高于StringBuffer和String</p>
<p>② String是一个常量，不可变，进行每一次拼接都会创建一个新的对象，会产生许多的临时对象，导致GC（垃圾回收机制）开始工作，影响系统性能；StringBuilder和StringBuffer的是可变，当进行字符串拼接时采用append方法，在原来的基础上进行追加，所以比String性能高，又因为StringBuffer是线程安全，StringBuilder是线程不安全，所以StringBuilder比StringBuffer性能高，但是默认使用StringBuffer</p>
<p>③ 对于大数据量的字符串的拼接，使用StringBuffer和StringBuilder</p>
<h3 id="（9）Hashtable和Hashmap的区别"><a href="#（9）Hashtable和Hashmap的区别" class="headerlink" title="（9）Hashtable和Hashmap的区别"></a>（9）Hashtable和Hashmap的区别</h3><blockquote>
<p>Hashtable线程安全，HashMap线程不安全</p>
<p>Hashtable不允许NUll值（key和value都不可以），HashMap可以允许NUll值（key和value都可以）</p>
<p>两者的遍历大同小异，Hashtable仅仅比HashMap多一个elements方法（遍历输出value值）</p>
</blockquote>
<h3 id="（10）常见的编译时异常"><a href="#（10）常见的编译时异常" class="headerlink" title="（10）常见的编译时异常"></a>（10）常见的编译时异常</h3><blockquote>
<p>SQLException：数据库访问错误或者其他错误消息的异常</p>
<p>IOException：由失败或中断的I&#x2F;O操作产生的异常</p>
<p>FileNotFoundException:  打开指定路径名表示的文件失败时，抛出的异常</p>
<p>ClassNotFoundException:  找不到具有指定名称的类的定义抛出的异常</p>
<p>EOFException:  当输入过程中意外到达文件或流的末尾时，抛出的异常</p>
</blockquote>
<h3 id="（11）方法重载和方法重写的区别"><a href="#（11）方法重载和方法重写的区别" class="headerlink" title="（11）方法重载和方法重写的区别"></a>（11）方法重载和方法重写的区别</h3><blockquote>
<p><strong>方法重载：</strong>方法名一致，参数列表中参数的顺序，类型，个数不同；重载与方法的返回值类型无关；存在同一个类中，可以抛出不同的异常，可以有不同修饰符</p>
</blockquote>
<blockquote>
<p><strong>方法重写：</strong>参数列表，方法名，返回值类型必须完全一致，构造方法不能被重写；声明为final的方法不能被重写；声明为static的方法不存在重写；访问权限不能比父类低；重写之后的方法不能抛出更大的异常；发生在父类和子类中</p>
</blockquote>
<h3 id="（12）throw和throws的区别"><a href="#（12）throw和throws的区别" class="headerlink" title="（12）throw和throws的区别"></a>（12）throw和throws的区别</h3><blockquote>
<p><strong>throw：</strong>用于方法体中，表示抛出异常，由方法体内的语句处理；throw是具体向外抛出异常的动作，抛出的是一个异常实例，执行throw是一定抛出了某种异常</p>
</blockquote>
<blockquote>
<p><strong>throws：</strong>用于方法声明后面，表示可能抛出异常，由该方法的调用者去处理异常（简称向上“抛”）；throws主要是声明这个方法可能会抛出某种类型的异常，让调用者知道需要捕捉的异常类型；throws表示的是一种可能，但是不一定会发生的异常</p>
</blockquote>
<h3 id="（13）权限修饰符的区别"><a href="#（13）权限修饰符的区别" class="headerlink" title="（13）权限修饰符的区别"></a>（13）权限修饰符的区别</h3><table>
<thead>
<tr>
<th></th>
<th>同一个类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td>public（共有的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected（受保护的）</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>default（默认的）</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private（私有的）</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="（14）为什么重写equals方法时必须重写hashCode方法？"><a href="#（14）为什么重写equals方法时必须重写hashCode方法？" class="headerlink" title="（14）为什么重写equals方法时必须重写hashCode方法？"></a>（14）为什么重写equals方法时必须重写hashCode方法？</h3><blockquote>
<p>hashCode（）的作用是获取哈希码，也称为散列码，返回的是一个int整数；哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p>根据源码中的注释中得知：当重写equals方法后有必要将hashCode方法重写，这样做才能保证不违背hashCode方法中“相同对象必须要有相同哈希值”的约定</p>
<p>那么hashCode方法约定又是什么呢？</p>
<p>总结为三大点：</p>
<p>① 如果对象在使用equals方法中比较的参数没有修改，那么多次调用一个对象的hashCode方法放回的哈希值是相同的</p>
<p>② 如果两个对象通过equals方法比较是相等的，那么要求这两个对象的hashCode返回的哈希值也应该相同的</p>
<p>③ 如果两个对象通equals方法比较是不同的，那么也不要求这两个对象的hashCode方法返回的值是不相同的（但是我们应该知道对于不同对象产生不同的哈希值对于哈希表能够提高性能的）</p>
</blockquote>
<p>借鉴：[Java面试题：重写了equals，还要重写hashCode？ | w3c笔记 (w3cschool.cn)](<a href="https://www.w3cschool.cn/article/4adce89bf8b821.html#:~:text=%E5%A4%A7%E8%87%B4%E6%84%8F%E6%80%9D%E6%98%AF%EF%BC%9A%E5%BD%93%E9%87%8D%E5%86%99">https://www.w3cschool.cn/article/4adce89bf8b821.html#:~:text=大致意思是：当重写</a> equals 方法后有必要将 hashCode 方法也重写，这样做才能保证不违背 hashCode,方法中”相同对象必须有相同哈希值”的约定。 此处只是提醒了我们重写 hashCode 方法的必要性，那其中提到的 hashCode 方法设计约定又是什么呢？)</p>
<h3 id="（15）HashSet和TreeSet有什么区别？"><a href="#（15）HashSet和TreeSet有什么区别？" class="headerlink" title="（15）HashSet和TreeSet有什么区别？"></a>（15）HashSet和TreeSet有什么区别？</h3><blockquote>
<p>HashSet: 由一个hash表实现，它的元素是无序的，add(),remove(),contains()方法的时间复杂度为O(1)</p>
<p>TreeSet：由一个树形的结构来实现的，它里面的元素是有序的，add(),remove(),contains()方法的时间复杂度是O(logn)</p>
</blockquote>
<h3 id="（16）强引用，弱引用，软引用，虚引用的区别"><a href="#（16）强引用，弱引用，软引用，虚引用的区别" class="headerlink" title="（16）强引用，弱引用，软引用，虚引用的区别"></a>（16）强引用，弱引用，软引用，虚引用的区别</h3><blockquote>
<p><strong>强引用（StrongReference）：</strong>最普遍的一种引用方式，例如String s &#x3D; “abc”，变量s就是字符串“abc”的强引用，只要强引用存在，则垃圾回收器就不会回收这个对象。</p>
<p><strong>软引用（SoftReference）：</strong>用于描述还要用非必须的对象，如果内存足够，不回收，如果内存不足时，则回收。一般用于双向内存敏感的<strong>高速缓存</strong>，软引用可以和队列ReferenceQueue联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中</p>
<p><strong>弱引用（WeakReference）</strong>：弱引用与软引用大致相同，弱引用与软引用的区别：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存</p>
<p><strong>虚引用（PhantomReference）：</strong>就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象只有虚引用，那么它和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用只要用来跟踪对象被垃圾回收器回收的活动。</p>
<p>虚引用与弱引用和软引用的一个区别：虚引用必须与引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
</blockquote>
<p>详情：<a href="https://cloud.tencent.com/developer/article/1408097">Java 的强引用、弱引用、软引用、虚引用 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h3 id="（17）new一个对象的过程和clone一个对象的过程"><a href="#（17）new一个对象的过程和clone一个对象的过程" class="headerlink" title="（17）new一个对象的过程和clone一个对象的过程"></a>（17）new一个对象的过程和clone一个对象的过程</h3><blockquote>
<p>new一个对象：当程序执行到new操作符时，会先去确定new 的对象类型，因为知道了数据类型，才能知道要分配多大的内存空间。分配完内存，再调用构造函数，填充对象的各个域，这是对象的初始化，构造函数放回后，对象创建完成，将它的引用地址发布到外部，就可以通过这个引用来操作这个对象</p>
<p>clone一个对象：调用clone方法时，先分配内存，与原对象的内存空间相同，再使用原对象中对应的各个域，填充新对象的各个域，完成后，clone方法返回，一个新的相同的对象被创建好，将引用发布到外部 </p>
</blockquote>
<h3 id="（18）Java中-x3D-x3D-和equals的区别"><a href="#（18）Java中-x3D-x3D-和equals的区别" class="headerlink" title="（18）Java中&#x3D;&#x3D;和equals的区别"></a>（18）Java中&#x3D;&#x3D;和equals的区别</h3><blockquote>
<p>&#x3D;&#x3D; 是判断两个变量或实例是不是指向同一个内存空间；equals是判断两个变量或者实例所指向的内存空间内的值是否相同</p>
</blockquote>
<h3 id="（19）final，finalize和finally的区别"><a href="#（19）final，finalize和finally的区别" class="headerlink" title="（19）final，finalize和finally的区别"></a>（19）final，finalize和finally的区别</h3><blockquote>
<p>final：用于声明属性，方法和类，分别表示属性不可变，方法不可被覆盖，类不可被继承</p>
<p>finally：为异常处理语句结构的一部分，表示总是执行</p>
<p>finalize：为object类中的一个方法，在垃圾回收器执行的时候会调用该对象的此方法，可以覆盖此方法提供方法垃圾收集时的其他资源回收，例如关闭文件。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。</p>
</blockquote>
<h3 id="（20）Java创建对象的几种方式"><a href="#（20）Java创建对象的几种方式" class="headerlink" title="（20）Java创建对象的几种方式"></a>（20）Java创建对象的几种方式</h3><blockquote>
<p>new 创建新对象</p>
<p>通过反射机制</p>
<p>采用clone机制（实现Cloneable接口）</p>
<p>通过序列化机制（实现Serializable接口）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// new</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> String.class;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) clazz.newInstance();</span><br><span class="line">        <span class="comment">// 使用clone方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> (String)s2.clone();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化机制参考：<a href="https://blog.csdn.net/qq_19782019/article/details/80422143">(38条消息) Java基础——对象的序列化（通俗易懂，排版优美）_刘扬俊的博客-CSDN博客</a></p>
<h3 id="（21）-amp-和-amp-amp-的区别"><a href="#（21）-amp-和-amp-amp-的区别" class="headerlink" title="（21）&amp;和&amp;&amp;的区别"></a>（21）&amp;和&amp;&amp;的区别</h3><blockquote>
<p>相同点：最终得到的boolean值结果一样</p>
<p>不同点：&amp;既是逻辑运算符也是位运算,&amp;&amp;只是逻辑运算符；&amp;不具有短路效果，即左边false，右边也会执行，&amp;&amp;具有短路效果，左边为false，右边不会执行</p>
</blockquote>
<h3 id="（22）内部类有什么作用？"><a href="#（22）内部类有什么作用？" class="headerlink" title="（22）内部类有什么作用？"></a>（22）内部类有什么作用？</h3><blockquote>
<p>1、内部类可以很好的实现隐藏，一般的非内部类，是不允许有private，protected权限的，但内部类可以</p>
<p>2、内部类拥有外围类的所有元素的访问权限（内部类是外部类的一部分）</p>
<p>3、可以间接实现多继承</p>
<p>4、可以避免修改接口而实现同一个类中两种同名方法的调用</p>
</blockquote>
<p>借鉴：<a href="https://blog.csdn.net/u013728021/article/details/87358517">(38条消息) java内部类的四大作用_奋斗的bigHead的博客-CSDN博客</a></p>
<h3 id="（23）深拷贝和浅拷贝的区别是什么？"><a href="#（23）深拷贝和浅拷贝的区别是什么？" class="headerlink" title="（23）深拷贝和浅拷贝的区别是什么？"></a>（23）深拷贝和浅拷贝的区别是什么？</h3><blockquote>
<p><strong>浅拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的对象，而所有的对其他对象的引用仍然指向原来的对象。简而言之，浅拷贝仅仅复制考虑的对象，不能复制它引用的对象。</p>
<p><strong>深拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的值，且原对象那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。简而言之，深拷贝把复制的对象所引用的对象都复制了一遍。</p>
</blockquote>
<h3 id="（24）static的用法"><a href="#（24）static的用法" class="headerlink" title="（24）static的用法"></a>（24）static的用法</h3><blockquote>
<p>Static可以修饰内部类、方法、变量、代码块</p>
<p>Static修饰的类为静态内部类</p>
<p>Static修饰的方法为静态方法，表示该方法属于当前类，类的所有对象共有；静态方法不能被重写；可以直接用类名点的形式调用；静态方法内不能使用this和super关键字</p>
<p>Static修饰的变量为静态变量，静态变量被所有实例共享，不依赖于某个对象；静态变量在内存只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存</p>
<p>Static修饰的代码块为静态代码块，被用于程序优化；静态代码块中的代码在整个类加载的时候只会执行一次；静态代码块可以有多个，如果有多个，按照先后顺序依次执行</p>
</blockquote>
<h3 id="（25）什么是值传递和引用传递"><a href="#（25）什么是值传递和引用传递" class="headerlink" title="（25）什么是值传递和引用传递"></a>（25）什么是值传递和引用传递</h3><blockquote>
<p><strong>值传递：</strong>在调用方法时将实际参数复制一份传递到方法中，在方法中对参数进行修改，不会影响到实际参数</p>
<p><strong>引用传递：</strong>在调用方法时将实际参数的地址直接传递在方法内，在方法内对参数进行的修改，将会影响到实际参数</p>
<p><strong>本质上的区别：</strong>实际参数是复制一份还是直接被拿去使用</p>
</blockquote>
<p>详细：<a href="https://blog.csdn.net/u013728021/article/details/87358517">(38条消息) java内部类的四大作用_奋斗的bigHead的博客-CSDN博客</a></p>
<h3 id="（26）成员变量与局部变量的区别有哪些？"><a href="#（26）成员变量与局部变量的区别有哪些？" class="headerlink" title="（26）成员变量与局部变量的区别有哪些？"></a>（26）成员变量与局部变量的区别有哪些？</h3><blockquote>
<p>1、从语法形式上，成员变量属于类，局部变量是在方法内定义的变量或者是方法的参数；成员变量可以被public，private，protected等修饰符修饰，而局部变量不能被权限修饰符和static所修饰（两者都能被final修饰）</p>
<p>2、从变量的内存存储位置看，成员变量属于对象的一部分，对象存在于堆内存；局部变量存在与栈内存</p>
<p>3、从变量在内存中的生存时间上看，成员变量随着对象的创建而存在；局部变量随着方法的调用而自动消失</p>
<p>4、成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（当被final和static修饰时（常量），一定要赋值）；局部变量没有被赋初值时，则不会被自动赋值</p>
</blockquote>
<h3 id="（27）静态方法和实例方法有何不同？"><a href="#（27）静态方法和实例方法有何不同？" class="headerlink" title="（27）静态方法和实例方法有何不同？"></a>（27）静态方法和实例方法有何不同？</h3><blockquote>
<p>1、在外部调用静态方法时，可以用类名点的形式调用，也可以使用对象名点的形式调用，而调用实例方法只能是后者调用；调用静态方法无需创建对象，调用实例方法一定要创建对象</p>
<p>2、静态方法只能访问本类的静态成员（即静态成员变量和静态方法）。而实例方法没有限制</p>
</blockquote>
<h3 id="（28）多态是什么？"><a href="#（28）多态是什么？" class="headerlink" title="（28）多态是什么？"></a>（28）多态是什么？</h3><blockquote>
<p>多态是同一行为具有不同表现形式或形态的能力，即对象多种表现形式的体现，就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
</blockquote>
<h3 id="（29）多态存在的三个必要条件"><a href="#（29）多态存在的三个必要条件" class="headerlink" title="（29）多态存在的三个必要条件"></a>（29）多态存在的三个必要条件</h3><blockquote>
<p>1、一定要有继承</p>
<p>2、要有方法的重写</p>
<p>3、父类引用指向子类对象（父类类型 变量名 &#x3D; new 子类构造器）</p>
</blockquote>
<h3 id="（30）TreeMap，HashMap，LinkedHashMap的区别"><a href="#（30）TreeMap，HashMap，LinkedHashMap的区别" class="headerlink" title="（30）TreeMap，HashMap，LinkedHashMap的区别"></a>（30）TreeMap，HashMap，LinkedHashMap的区别</h3><blockquote>
<p>TreeMap：存储有序，默认时按key的升序排序，也可以指定比较器；当使用迭代器（Iterator）遍历时，得到的结果时排过序的</p>
<p>HashMap：存储无序，具有很快的访问速度；只允许一条元素的key为null，value没有限制；不支持线程的同步</p>
<p>LinkedHashMap：存储有序</p>
</blockquote>
<p>详细：<a href="https://www.cnblogs.com/acm-bingzi/p/javaMap.html">HashMap,LinkedHashMap,TreeMap的区别（转） - 贾树丙 - 博客园 (cnblogs.com)</a></p>
<h3 id="（31）什么是反射"><a href="#（31）什么是反射" class="headerlink" title="（31）什么是反射"></a>（31）什么是反射</h3><blockquote>
<p>在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取信息以及动态调用对象的功能称为Java反射机制</p>
<p>反射就是动态加载对象，并对对象进行剖析。</p>
</blockquote>
<h3 id="（32）反射的作用"><a href="#（32）反射的作用" class="headerlink" title="（32）反射的作用"></a>（32）反射的作用</h3><blockquote>
<p>1、在运行时判断任意一个对象所属的类型</p>
<p>2、在运行时构造任意一个类的对象</p>
<p>3、在运行时判断任意一个类所具备的成员变量和方法</p>
<p>4、在运行时调用任意一个对象的方法</p>
</blockquote>
<h3 id="（33）break和continue的区别"><a href="#（33）break和continue的区别" class="headerlink" title="（33）break和continue的区别"></a>（33）break和continue的区别</h3><blockquote>
<p>两者都是用来控制循环的语句</p>
<p>break用来完全结束一个循环语句，跳出循环体执行后面的语句</p>
<p>continue是跳过本次循环，直接进行下次循环</p>
</blockquote>
<h3 id="（34）运行时异常与一般异常有何异同"><a href="#（34）运行时异常与一般异常有何异同" class="headerlink" title="（34）运行时异常与一般异常有何异同"></a>（34）运行时异常与一般异常有何异同</h3><blockquote>
<p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。</p>
<p>Java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
</blockquote>
<h3 id="（35）Collection和Collections的区别"><a href="#（35）Collection和Collections的区别" class="headerlink" title="（35）Collection和Collections的区别"></a>（35）Collection和Collections的区别</h3><blockquote>
<p>Collection时集合类的上级接口。继承它的接口主要有Set和List</p>
<p>Collections是针对集合类的一个工具类（帮助类），提供了一系列静态方法实现对各种集合的搜索，排序，线程安全化等操作。简化了对集合的操作</p>
</blockquote>
<h3 id="（36）Error和Exception有什么区别"><a href="#（36）Error和Exception有什么区别" class="headerlink" title="（36）Error和Exception有什么区别"></a>（36）Error和Exception有什么区别</h3><blockquote>
<p>Error：是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</p>
<p>Exception：表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
</blockquote>
<p>详细：<a href="https://blog.csdn.net/weixin_43698561/article/details/104382643">(38条消息) 面试题整理:Error与Exception的区别_exception与error区别_Jxfor。的博客-CSDN博客</a></p>
]]></content>
  </entry>
  <entry>
    <title>八股文（架构）</title>
    <url>/2023/07/07/Java%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%9E%B6%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JVM问题"><a href="#JVM问题" class="headerlink" title="JVM问题"></a>JVM问题</h1><h2 id="什么是进程和线程？"><a href="#什么是进程和线程？" class="headerlink" title="什么是进程和线程？"></a>什么是进程和线程？</h2><blockquote>
<p><strong>进程：</strong>进程是程序的一次执行过程，是系统运行的基本单位</p>
<p><strong>线程：</strong>线程是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程</p>
</blockquote>
<h2 id="内存泄露与内存溢出的区别"><a href="#内存泄露与内存溢出的区别" class="headerlink" title="内存泄露与内存溢出的区别"></a>内存泄露与内存溢出的区别</h2><blockquote>
<p><strong>内存泄露：</strong>程序在申请内存后，无法释放已申请的内存空间</p>
<p><strong>ThreadLocal内存泄露问题是怎么导致的？如何解决？</strong></p>
<p>ThreadLocal中使用的Key为ThreadLocal的弱引用，但是Value是强引用，在垃圾回收时，key会被回收，但是Value是不会的，这样一来会出现Key为null的Entry，假如不做任何处理，Key为null的Entry永远都不会被回收，久而久之就造成了内存泄漏。使用完ThreadLocal建议调用remove方法。</p>
<p><strong>内存溢出：</strong>程序申请内存时，没有足够的内存空间供其使用（OOM问题 OutOfMemory）</p>
</blockquote>
<h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><blockquote>
<ul>
<li>堆</li>
<li>栈：由一个个栈帧组成</li>
<li>本地方法栈</li>
<li>程序计数器</li>
<li>方法区（元空间）</li>
</ul>
</blockquote>
<h2 id="Java对象的创建过程"><a href="#Java对象的创建过程" class="headerlink" title="Java对象的创建过程"></a>Java对象的创建过程</h2><blockquote>
<p>① 类加载检查：先去常量池中去定位这个类的符号引用，并检查这个符号引用代表的类是否被加载过、解析和初始化过，没有，执行相对应的类加载过程（双亲委派机制）</p>
<p>② 分配内存：虚拟机为新生对象分配内存，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有<strong>“指针碰撞”</strong>和<strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</strong></p>
<p>​	<strong>指针碰撞：</strong>适用场景：堆内存规整的情况下</p>
<p>​						原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需									要向着没用过的内存方向将该指针移动对象内存大小位置即可。</p>
<p>​						GC收集器：Serial，ParNew</p>
<p>​	<strong>空闲列表：</strong>使用场景：堆内存不完整的情况下</p>
<p>​						原理：虚拟机维护一个列表，该列表记录哪个内存块是可用的，分配的时候，找一块足够大的									内存块分配给对象实例，最后更新列表记录。</p>
<p>​						GC收集器：CMS</p>
<p>​	Java堆内存是否完整取决于GC收集器的算法是”标记-清除“，还是”标记-整理“，复制算法堆内存也是完整的。（垃圾回收算法：分代收集理论，标记-复制算法，标记-整理算法，标记-清楚算法）</p>
<p>​	<strong>内存分配并发问题：</strong></p>
<p>​		CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></p>
<p>​		TLAB(Thread Local Allocation Buffer，本地线程分配缓冲)：为每一个线程预先在Eden区分配一块内存，JVM给线程中的对象分配内存时，会优先在TLAB中分配，当TLAB中的内存用尽时，再采用上述的CAS进行内存分配。</p>
<p>③ 初始化</p>
<p>​	内存分配完，虚拟机将分配到的内存空间都初始化为零值（不包含对象头），这一步操作保障了对象的实例在Java代码中可以不赋初始值就可以直接使用，程序可以直接访问到这些字段的数据类型所对应的零值。</p>
<p>④ 设置对象头</p>
<p>​	初始化完成，虚拟机堆对象进行必要的设置。例如该对象是哪个类的实例、如何能找到类的元数据信息、该对象的哈希码、对象的GC分代年龄等信息，这些信息都会存放在对象头中。另外，虚拟机会根据当前的运行状态，如是否启用偏向锁，对象头会有不同的设置方式。</p>
<p>⑤ 执行init方法</p>
<p>​	上述步骤完成，在虚拟机的角度看，一个新的对象已经创建完成，但是在JAVA程序的角度来看，对象创建才刚开始，init方法没有执行，所有字段都是零。执行new指令之后会接着执行init方法，把对象按照程序员的意愿进行初始化，这样真正可用的对象才算完整产生出来。</p>
</blockquote>
<h2 id="如何打破双亲委派机制？"><a href="#如何打破双亲委派机制？" class="headerlink" title="如何打破双亲委派机制？"></a>如何打破双亲委派机制？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintClassLoaderTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> PrintClassLoaderTree.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">split</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;|--&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needContinue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (needContinue)&#123;</span><br><span class="line">            System.out.println(split.toString() + classLoader);</span><br><span class="line">            <span class="keyword">if</span>(classLoader == <span class="literal">null</span>)&#123;</span><br><span class="line">                needContinue = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                classLoader = classLoader.getParent();</span><br><span class="line">                split.insert(<span class="number">0</span>, <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|--sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    |--sun.misc.Launcher$ExtClassLoader@53bd815b</span><br><span class="line">        |--null</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于BootstrapClassLoader是C++实现的，在Java中没有相对应的类，所以拿到的值为null。</p>
<p> 除了BootstrapClassLoader之外，其余类加载器都是继承自java.lang.ClassLoader。打破双亲委派机制就需要我们自定义类加载器，继承ClassLoader抽象类即可，并重写loadClass()方法，不盲目向上寻找，就是打破了JVM的双亲委派机制；如果不打破该机制，只需重写findClass()方法。</p>
<p>如：Tomcat就打破就双亲委派机制。</p>
</blockquote>
<h1 id="Redis问题"><a href="#Redis问题" class="headerlink" title="Redis问题"></a>Redis问题</h1><h2 id="缓存击穿，缓存穿透，缓存雪崩的区别以及解决方法"><a href="#缓存击穿，缓存穿透，缓存雪崩的区别以及解决方法" class="headerlink" title="缓存击穿，缓存穿透，缓存雪崩的区别以及解决方法"></a>缓存击穿，缓存穿透，缓存雪崩的区别以及解决方法</h2><blockquote>
<p><strong>缓存击穿：</strong>缓存中存在该数据，但是当请求发送过来时，数据刚好过期，导致大量的请求并发打到数据库，导致数据库宕机</p>
<p>解决方案：</p>
<p>① 条件允许下，可以将热点数据设置为永久数据</p>
<p>② 使用分布式锁，拿到锁的请求才能去访问数据库</p>
</blockquote>
<blockquote>
<p><strong>缓存穿透：</strong>大量请求一个不存的空数据，缓存中并没有这个空数据的key，导致大量请求去访问数据库，数据库因为压力而宕机</p>
<p>解决方案：</p>
<p>① 在缓存中存入一个空对像的key</p>
<p>②使用布隆过滤器，在请求缓存之前就做一层判断，如果存在就去访问缓存，如果不存在就直接返回。（注：布隆过滤器存在一定的误判率）</p>
</blockquote>
<blockquote>
<p><strong>缓存雪崩：</strong>与缓存击穿相类似，只不过缓存雪崩是大量的key同一时间失效，导致请求全部打到数据库上</p>
<p>解决方案：</p>
<p>① 给数据设置不同的过期时间，尽量避免数据同时过期</p>
<p>② 熔断机制，保障一部分人的正常使用</p>
<p>③ 提高数据库的容灾能力，使用分库分表，读写分离的策略</p>
<p>④ 搭建redis集群</p>
</blockquote>
<h2 id="Redis-常用数据结构"><a href="#Redis-常用数据结构" class="headerlink" title="Redis 常用数据结构"></a>Redis 常用数据结构</h2><blockquote>
<p>① string（字符串）</p>
<p>② list（列表）：存储一个有序的字符串集合，支持快速添加、删除和获取元素，以及支持通过索引查找元素</p>
<p>③ set（集合）：存储的是无序的元素集合，并支持集合间的基本集合运算，如交集、并集、差集等。</p>
<p>④ hash（散列表）：通过key-value存储数据，key为字符串类型，value为字符串和整数型</p>
<p>⑤ zset（有序集合）：存储的是一个有序的字符串集合，每个元素都有一个关联的分数，可以通过分数进行排序和范围查询。</p>
</blockquote>
<h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><blockquote>
<p>散列、列表、跳跃表</p>
</blockquote>
<h2 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h2><blockquote>
<p><strong>AOF:</strong> 将Redis所执行的所有指令都记录下来，在下次Redis重启时，只需要执行指令就可以了。</p>
<p>实现方式：配置文件中开启aof支持，redis服务器启动时，会直接fork一个子线程，会直接在数据目录下创建aof文件，但是文件内容为空，后续每一个操作指令都会被保存在这个文件中。</p>
<p>优点：数据丢失的风险大大降低，最多丢失1秒的数据</p>
<p>缺点：数据文件比rdb大，使用aop文件进行数据恢复的时候速度较慢</p>
<p>优化方式：当aof文件较大时，可以手动重写，输入bgrewriteaof，也可以自动重写，两个参数auto-aof-rewrite-percentage（比例，下一次文件大小与上一次文件大小的比较） 和auto-aof-rewrite-min-size（触发重写时的文件最大值）</p>
<p>注：由于重写也是主线程重新fork一个子线程，去进行数据操作，fork子线程会带来redis服务器的性能损耗，重写的频率不要太频繁。</p>
</blockquote>
<blockquote>
<p><strong>RDB:</strong> 定期更新，定期将Redis中的数据生成的快照同步到磁盘等介质上，磁盘上保存的是Redis 的内存快照。</p>
<p>实现方式：</p>
<p>​	① save ：在当前的Redis服务器进程进行RDB持久化，会阻塞其他客户端的指令，禁止使用</p>
<p>​	② bgsave：基于当前的Redis服务器fork一个子线程去执行RDB持久化，不会阻塞其他客户端的指令</p>
<p>优点：数据文件比AOF小，使用RDB恢复数据速度较快</p>
<p>缺点：比较耗时，存在丢失数据的风险。</p>
</blockquote>
<blockquote>
<p><strong>混合型持久化方案：</strong>aof-use-rdb-preamble yes配置文件</p>
<p>特点：</p>
<p>​	① Redis4.0之后默认开启，之前是RDB</p>
<p>​	② 开启后，aof重写的部分会以RDB方式保存，后续的操作依旧以aop指令形式保存</p>
<p><strong>选择方案：</strong></p>
<ul>
<li>追求恢复效率，对数据安全要求不高，选择RDB</li>
<li>不追求恢复效率，对数据要求高，选择AOF</li>
<li>既要追求恢复效率，对数据要求高，选择混合型持久化</li>
</ul>
</blockquote>
<h2 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h2><h3 id="删除方式："><a href="#删除方式：" class="headerlink" title="删除方式："></a>删除方式：</h3><ol>
<li><p><strong>定时删除：</strong>Redis未使用</p>
</li>
<li><p><strong>定期删除：</strong>Redis中的数据过期后，会将过期数据的键记录到过期字典中，在服务器内部中，有一个专门的线程去扫描这个过期字典，将过期字典中过期的键对应的值删除，所以过期数据不是立即删除。</p>
</li>
<li><p><strong>惰性删除：</strong>当我们去获取一个过期的键的值时，如果这个键没有被定期删除，我们也不会获取到这个值，redis服务器会直接删除这个值。</p>
<blockquote>
<p>注：惰性删除的触发机制是需要自动获取那个键对应的值，如果键过期了，但是没有主动去获取，那么这个键对应的值就会一直留在redis内存中，造成内存浪费。</p>
</blockquote>
</li>
</ol>
<h3 id="淘汰策略："><a href="#淘汰策略：" class="headerlink" title="淘汰策略："></a>淘汰策略：</h3><h3 id="常见的淘汰算法："><a href="#常见的淘汰算法：" class="headerlink" title="常见的淘汰算法："></a>常见的淘汰算法：</h3><ul>
<li>LRU算法：基于数据的历史访问记录来进行淘汰，及缓存数据最近被访问的数据会被保留下来，而没被访问的数据会被清楚。实现方式可以是使用一个列表记录所有的缓存数据，每当有数据被访问时，将数据移动到最前端，当缓存满时，淘汰列表最后的数据。</li>
<li>LFU算法：基于数据的访问频度来进行淘汰，及缓存数据访问频度较高的数据会被保留下来，而访问频度较低的数据会被清除。该算法的实现方式可以使用一个计数器来记录每个数据的访问频度，当缓存满时，淘汰使用频度最低的数据，如果多个数据使用频度一样，则选择最近最少使用的数据进行淘汰。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) </span><br><span class="line"># 3）volatile-random 移除设置过过期时间的随机key</span><br><span class="line"># 5）volatile-lfu：在内存不足时，Redis会在设置过了生存时间的key中干掉一个最少频次使用的key。</span><br><span class="line"># 7）volatile-ttl   移除即将过期的key(minor TTL) </span><br><span class="line"></span><br><span class="line"># 2）allkeys-lru   利用LRU算法移除任何key </span><br><span class="line"># 4）allkeys-random  移除随机key </span><br><span class="line"># 6）allkeys-lfu：在内存不足时，Redis会在全部的key中干掉一个最少频次使用的key。</span><br><span class="line"></span><br><span class="line"># 8）noeviction  不移除任何key，只是返回一个写错误 。默认选项</span><br></pre></td></tr></table></figure>

<h2 id="Redis的分布式锁实现"><a href="#Redis的分布式锁实现" class="headerlink" title="Redis的分布式锁实现"></a>Redis的分布式锁实现</h2><h1 id="Spring问题"><a href="#Spring问题" class="headerlink" title="Spring问题"></a>Spring问题</h1><h2 id="Spring的事务传播行为："><a href="#Spring的事务传播行为：" class="headerlink" title="Spring的事务传播行为："></a>Spring的事务传播行为：</h2><table>
<thead>
<tr>
<th>正确的事务传播行为</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>使用最多的一种事务传播行为，@Transactional默认传播行为。如果当前存在事务，则加入；没有，则创建一个事务</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>创建一个新的事务，如果当前存在事务，则挂起当前事务，被此传播行为修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则创建一个新的事务</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>如果存在事务，则加入事务；没有事务，则抛出异常</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>错误的事务传播行为</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SUPPORTS</td>
<td>如果存在事务，则加入该事务；如果没有事务，则以非事务的方式继续运行</td>
</tr>
<tr>
<td>NOT_SOPPORTED</td>
<td>以非事务的方式运行，如果存在事务，则挂起当前事务</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式运行，如果当前存在事务，则抛出异常</td>
</tr>
</tbody></table>
<h2 id="Spring事务什么情况下会失效"><a href="#Spring事务什么情况下会失效" class="headerlink" title="Spring事务什么情况下会失效"></a>Spring事务什么情况下会失效</h2><blockquote>
<p><a href="https://cloud.tencent.com/developer/article/2233995">Spring事务失效的12种场景-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</blockquote>
<h2 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h2><blockquote>
<p><strong>两者的关系：</strong></p>
<p>​	BeanFactory是Spring框架最核心的接口，提供了loc的配置机制；ApplicationContext继承了BeanFactory接口，拥有BeanFactory所有功能。一般称BeanFactory为IoC容器，而称ApplicationContext为应用上下文。y</p>
<p><strong>两者的区别：</strong></p>
<p>​	BeanFactory是懒加载，ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean，可以指定为延迟加载。</p>
<p> BeanFactory在初始化容器时，并未实例化Bean，如果Bean的某一个属性没有注入，BeanFacotry加载后，直至首次调用getBean方法才会抛出异常；而ApplicationContext则在初始化应用上下文时初始化所有单实例的Bean，这样有利于检查所依赖属性是否已经注入。综上所述，通常情况下我们首选ApplicationContext。</p>
<p>  由于ApplicationContext会预先初始化所有的Singleton Bean，于是在系统创建前期会有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取Singleton Bean实例时候将有较好的性能。</p>
</blockquote>
<h2 id="Spring的循环依赖问题如何解决："><a href="#Spring的循环依赖问题如何解决：" class="headerlink" title="Spring的循环依赖问题如何解决："></a>Spring的循环依赖问题如何解决：</h2><blockquote>
<p>再解决问题之前，引入一个spring的三级缓存概念：</p>
<table>
<thead>
<tr>
<th align="center">缓存名称</th>
<th align="center">源码名称</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一级缓存</td>
<td align="center">singletonObjects</td>
<td align="center">单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</td>
</tr>
<tr>
<td align="center">二级缓存</td>
<td align="center">earlySingletonObjects</td>
<td align="center">缓存早期的bean对象（生命周期还没走完）</td>
</tr>
<tr>
<td align="center">三级缓存</td>
<td align="center">singletonFactories</td>
<td align="center">缓存的是ObjectFactory，表示对象工厂，用来创建某个对象</td>
</tr>
</tbody></table>
<p><strong>Bean的生命周期：</strong></p>
<p>构造函数 —&gt; 依赖注入 —&gt; 检查是否继承Aware接口 —&gt;  BeanPostProcessr#before —&gt; 初始化方法 —&gt; BeanPostProcessr#after —&gt;销毁bean</p>
<p><strong>一级缓存和二级缓存解决（一般对象，不能是代理对象）</strong>：</p>
<p>A对象和B对象相会依赖，当A对象运行到依赖注入时，未完成的A对象被存储在二级缓存中，B对象进行创建时，会从二级缓存中获取A对象，进行对象的创建，并存入一级缓存中，这是A对象将从一级缓存取出B对象完成对象的创建。</p>
<p><img src="/../pic/%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p>
<p><strong>三级缓存解决（代理对象）：</strong></p>
<p>A对象和B对象相互依赖，A对象进行实例化时，会生成一个ObjectFactory放入三级缓存中，这时B对象进行实例化，也会生成一个ObjectFactory放入三级缓存中，A对象的ObjectFactory会根据B对象需要的对象形式进行生成相对应的对象，并将其放入二级缓存中，这是B对象完成依赖注入，放入一级缓存缓存中，A对象在一级缓存中获取B对象，完成初始化。</p>
<p><img src="/../pic/%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p>
<p><strong>上述缓存机制主要解决的是已经执行了构造方法的依赖问题，那么在构造方法中的依赖问题如何解决？</strong></p>
<p>使用懒加载的形式解决构造方法中的依赖问题，@Lazy注解</p>
</blockquote>
<h2 id="SpringMVC的请求处理流程："><a href="#SpringMVC的请求处理流程：" class="headerlink" title="SpringMVC的请求处理流程："></a>SpringMVC的请求处理流程：</h2><blockquote>
<p>首先是SpringMVC的核心组件：</p>
<p>1、<strong>DispatcherServlet：中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</p>
<p>2、<strong>HandlerMapping：处理器映射器</strong>，根据uri去匹配查找能处理的Handler，并会将请求涉及到的拦截器和Handler一起封装。</p>
<p>3、<strong>HandlerAdapter：处理器适配器</strong>，根据HandlerMapping找到的Handler，适配执行对应的Handler。</p>
<p>4、<strong>Handler：请求处理器</strong>，处理实际请求的处理器。</p>
<p>5、<strong>ViewResolver：视图解析器</strong>，根据Handler返回的逻辑视图&#x2F;视图，解析并渲染真正的视图，并传递给DispatcherServlet响应到客户端。</p>
<p><strong>流程说明（传统不分离项目流程）：</strong></p>
<p>① 客户端发送请求，DispatchedServlet拦截请求。</p>
<p>② DispatcherServlet根据请求信息调用HandlerMapping，Handler根据uri去匹配查找能处理的Handler（处理程序，也就是Controller），并将涉及到的拦截器和Handler一起封装，返回给DispatcherServlet。</p>
<p>③ DispatcherServlet调用HandlerAdapter适配器执行Handler。</p>
<p>④ Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView包含了数据模型以及对应的视图信息。</p>
<p>⑤ ViewResolver根据逻辑View找到实际的View。</p>
<p>⑥ DispatcherServlet将返回的Model传给View进行渲染。</p>
<p>⑦ 将view放回给请求者。</p>
<p><strong>流程说明（前后端分离项目流程）：</strong></p>
<p>① 客户端发送请求，DispatchedServlet拦截请求。</p>
<p>② DispatcherServlet根据请求信息调用HandlerMapping，Handler根据uri去匹配查找能处理的Handler（处理程序，也就是Controller），并将涉及到的拦截器和Handler一起封装，返回给DispatcherServlet。</p>
<p>③ DispatcherServlet调用HandlerAdapter适配器执行Handler。</p>
<p>④ 接口加上了@ResponseBody</p>
<p>⑤ 通过HttpMessageConverter来返回结果转化未JSON并响应</p>
</blockquote>
<h2 id="SpringBoot的起步器原理"><a href="#SpringBoot的起步器原理" class="headerlink" title="SpringBoot的起步器原理"></a>SpringBoot的起步器原理</h2><blockquote>
<p>@SpringBootApplication注解为一个复合注解，其包含的@EnableAutoConfiguration会自动装配，这是SpringBoot的核心注解。@EnableAutoConfiguration中引入了AutoConfigurationImportSelector类，该类中的getCandidateConfiguration方法会将所有自动配置的信息以List的形式返回，这些信息是以键值对的方式存储在META-INF&#x2F;spring.factories文件中。</p>
<p>@Conditional条件判断，SpringBoot自动装配了大量的配置类，但是不是所有都是一开始就被加载，要满足一些条件才会被加载。@Conditional就是条件判断，只有满足其中的条件，才会被加载，大大提高了SpringBoot的性能。</p>
</blockquote>
<h1 id="MySQL问题"><a href="#MySQL问题" class="headerlink" title="MySQL问题"></a>MySQL问题</h1><h2 id="并发事务会什么问题呢？"><a href="#并发事务会什么问题呢？" class="headerlink" title="并发事务会什么问题呢？"></a>并发事务会什么问题呢？</h2><p><strong>1、脏读</strong></p>
<blockquote>
<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务是可见的，即使该事务没有提交。这时另一个事务读取了改数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个的事务读取的就是脏数据，这就是脏读。</p>
</blockquote>
<p><strong>2、不可重复读</strong></p>
<blockquote>
<p>一个事务内多次读同一个数据，在这个事务没有结束时，另一个事务也访问了这个数据，那么在第一次事务两次读取数据之间，第二个事务对数据进行了修改，导致第一次事务两次读取的数据不同，这就是不可重复读。</p>
</blockquote>
<p><strong>3、幻读</strong></p>
<blockquote>
<p>发生在一个事务读取了几行数据，另一个事务插入了一些数据，在随后的查询中，第一个事务读取的数据有一些不同，就好像发生了幻觉一样，被称为幻读。</p>
</blockquote>
<h3 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h3><blockquote>
<ul>
<li>不可重复读的重点是内容修改或者记录减少</li>
<li>幻读的重点在于记录新增</li>
</ul>
<p>幻读其实可以看作不可重复读的一种特殊情况，单独区分幻读的主要原因是要解决幻读和不可重复读的方案不同。</p>
</blockquote>
<h2 id="MySQL的日志文件："><a href="#MySQL的日志文件：" class="headerlink" title="MySQL的日志文件："></a>MySQL的日志文件：</h2><h1 id="Zookpeer问题"><a href="#Zookpeer问题" class="headerlink" title="Zookpeer问题"></a>Zookpeer问题</h1><h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><blockquote>
<p>核心思想：客户端获取锁，则创建节点，使用完锁，则删除节点</p>
<p>实现步骤：</p>
<ol>
<li>客户端获取锁时，在lock节点创建临时顺序+监听节点</li>
<li>获取lock节点下的所有节点，进行比较顺序序号，如果自己是最小的，则获取锁；如果不是最小的，则注册事件监听器，对上一个比自己小的节点进行监听。</li>
<li>当监听上一个节点被删除是，则该客户端的监听器会接到通知，此时重复第二步。</li>
</ol>
<p><strong>临时节点的优点：</strong>当客户端因为异常挂掉或者正常执行业务关闭后，这个节点会被自动删除，不会出现后续进程获取不到锁的问题。</p>
<p><strong>顺序节点的好处：</strong>所有进程获取锁时，可以利用顺序好进行排队。</p>
<p>后续节点只会监听他的上一个节点，而不是他的父节点，如果监听的是父节点，某个节点删除是，其他所有节点都会参与抢锁操作，这种现象被称之为惊群效应，Redis分布式锁存在惊群效应。</p>
</blockquote>
<h1 id="微服务框架问题"><a href="#微服务框架问题" class="headerlink" title="微服务框架问题"></a>微服务框架问题</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="计算机网络问题"><a href="#计算机网络问题" class="headerlink" title="计算机网络问题"></a>计算机网络问题</h1><h2 id="OSI七层模型是什么？TCP-x2F-IP四层模型？"><a href="#OSI七层模型是什么？TCP-x2F-IP四层模型？" class="headerlink" title="OSI七层模型是什么？TCP&#x2F;IP四层模型？"></a>OSI七层模型是什么？TCP&#x2F;IP四层模型？</h2><table>
<thead>
<tr>
<th>OSI层次分层</th>
<th>作用</th>
<th>TCP&#x2F;IP模型</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>为计算机用户提供服务</td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>数据处理（编解码、加密解密、压缩解压缩）</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>管理（建立、维护、重连）应用程序之间的会话</td>
<td>应用层</td>
</tr>
<tr>
<td>传输层</td>
<td>为两台主机进程之间的通信提供通用的数据传输服务</td>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
<td>路由和寻址（决定数据在网络的游走路径）</td>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧编码和误差纠正</td>
<td></td>
</tr>
<tr>
<td>物理层</td>
<td>透明地传送比特流传输</td>
<td>网络接口层</td>
</tr>
</tbody></table>
<h2 id="应用层常用的协议"><a href="#应用层常用的协议" class="headerlink" title="应用层常用的协议"></a>应用层常用的协议</h2><blockquote>
<p><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于TCP协议，是一种传输超文本和多媒体内容的协议，主要为Web浏览器与Web服务器之间的通信而设计的。</p>
<p><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于TCP协议，是一种用于发送电子邮件的协议。注：SMTP只负责发送邮件，接收邮件需要使用POP3&#x2F;IMAP协议。</p>
<p><strong>POP3&#x2F;IMAP（邮件接收协议）</strong>：基于TCP协议，用于邮件的接收。IMAP是比POP3更新的协议。IMAP支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎现在所有的电子邮件客户端和服务器都支持IMAP协议。</p>
<p><strong>FTP（File Transfer Protocol，文件传输协议）</strong>：基于TCP协议，用于计算机之间传输文件，可以屏蔽操作系统和文件存储方式。注：FTP是一种不安全的协议，因为在传输过程中不对数据进行加密操作。建议在传输敏感数据，使用更安全的协议，如SFTP。</p>
<p><strong>Telnet（远程登录协议）</strong>：基于TCP协议，通过一个终端登录其他的服务器，但是所有数据都是明文传输，这存在安全问题。现在更多是使用SSH协议，一种安全的网络传输协议。</p>
<p><strong>SSH（Secure Shell Protocol）</strong>：基于TCP协议，通过加密和认证机制实现安全的访问和文件传输等业务。</p>
<p><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：基于UDP协议，支持TCP协议，提供了实时传输数据的功能，但不包含资源预留存、不保证传输质量，这些功能由WebRTP实现。</p>
<p><strong>DNS（Domain Name System，域名管理系统）</strong>：基于UDP协议，用于解决域名和IP地址的映射问题。</p>
</blockquote>
<h2 id="传输层常见的协议"><a href="#传输层常见的协议" class="headerlink" title="传输层常见的协议"></a>传输层常见的协议</h2><blockquote>
<p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>：提供面向连接的，可靠的数据传输服务。</p>
<p><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），简单高效。</p>
</blockquote>
<h2 id="网络层常见的协议"><a href="#网络层常见的协议" class="headerlink" title="网络层常见的协议"></a>网络层常见的协议</h2><blockquote>
<p><strong>IP（Internet Protocol，网际协议）</strong>：TCP&#x2F;IP协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便数据包可以跨网络传播并到达正确的目的地。目前IP协议，一为IPv4，一为IPv6。</p>
<p><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：只要解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<p><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，ping工具就是使用了ICMP协议来测试网络连通性。</p>
<p><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT协议的应用场景在网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在LAN外，在广域网（WAN）中，需要一个统一的IP地址来标识LAN在整个Internet上的位置。</p>
<p><strong>OSPF（Open Shorted Path First，开放式最短路径优先）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</p>
<p><strong>RIP（Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议，也是一种动态路由协议（Interior Gateway Protocol，IGP），基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</p>
<p><strong>BGP（Border Gateway Protocol，边界信息协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</p>
</blockquote>
<h2 id="输入URL到页面发生了什么？"><a href="#输入URL到页面发生了什么？" class="headerlink" title="输入URL到页面发生了什么？"></a>输入URL到页面发生了什么？</h2><blockquote>
<p>1、DNS解析：因为浏览器不能直接通过域名找到对应的IP服务器，所以需要DNS进行解析，找到相对应的IP服务器。</p>
<p>2、建立TCP连接（三次握手）</p>
<p>3、发送HTTP请求</p>
<p>4、相对应的IP服务器处理请求并返回HTTP报文</p>
<p>5、浏览器解析并渲染页面</p>
<p>6、连接结束</p>
</blockquote>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><blockquote>
<p><strong>端口号</strong>：HTTP默认是80，HTTPS默认是443</p>
<p><strong>URL前缀</strong>：HTTP的URL是http:&#x2F;&#x2F;，HTTPS的URL为https:&#x2F;&#x2F;</p>
<p><strong>安全性和资源消耗</strong>：HTTP协议运行在TCP之上，传输的内容都是明文，客户端和服务器之间都不能验证对方的身份。HTTPS是运行在SSL&#x2F;TLS之上的HTTP协议，SSL&#x2F;TLS是运行在TCP之上的，所有传输的内容都是密文，加密使用对称加密，但对称加密的密钥是用服务器方的证书进行非对称加密。所以说，HTTP安全性没有HTTPS高，但是HTTPS比HTTP消耗更多的资源。</p>
<p><strong>SEO（搜索引擎优化）</strong>：搜索引擎更青睐使用HTTPS协议的网站，因为HTTPS能够提供更高的安全性和用户隐私保护。使用HTTPS协议的网站在搜索结果中可能会被优先显示，从而对SEO产生影响。</p>
</blockquote>
]]></content>
  </entry>
</search>
